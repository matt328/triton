Render Layer
- takes in a list of things to render every frame
- queueRenderObjects(std::vector<RenderObject>);

Scene Layer
- Produces a list of things that need rendered every frame
- culling, octree, etc
- renderObject(renderable);

Game World Layer
- contains ECS
- Provides all renderables to the scene layer, via RenderSystem, RenderSystem contains reference to
   SceneLayer
- Provides logic to manipulate things from the scene layer, via ScriptSystem and/or other hard coded
   Systems
- createEntity(), assignComponentToEntity(), etc


ApplicationContext
- owns render, scene, and game
- has game loop
- fires events for input
- contains the actionmanager

Game
- for simplicity, remove all the pimpls, just move game logic into driver
- this is a base class that driver will extend to define the game
- has protected getters for ResourceFactory, ActionManager, others

- try creating a game, then passing the game into ApplicationContext(), then have ApplicationContext
  fire an event when graphics are initialized and game can begin, use that as a trigger for the game
  to start to load/run
  - This doesn't let you do pure raii with game resources, but resources will be loaded and unloaded
    during gameplay, so long as we put the game into a valid state after the ctor, raii is still
    maintained.
- Since the application knows about the game, fixedUpdate(), update() and render() can just be 
  virtual methods the game subclass will need to provide impls for
